
LIBNAME LIB_MENT BASE "/home/u63929852/SAS_Assignment";

FILENAME META '/home/u63929852/SAS_Assignment/metaverse_dataset.xlsx';

PROC IMPORT DATAFILE=META
out=LIB_MENT.METAVERSE
DBMS= xlsx
REPLACE;
GETNAMES=YES;
RUN;

/* Exploratory Data Analysis*/
/*1- converting amount and risk score to numerical values*/	 
DATA LIB_MENT.METAVERSE;
SET LIB_MENT.METAVERSE;
	Amd= input(amount, 8.);
	Risk_Per=input(risk_score, 8.);
	time_stamp= input(timestamp, ANYDTDTM19.);
	login=input(login_frequency, 8.);
	DATE=DATEPART(TIME_STAMP);
	TIME=hour(TIMEPART(TIME_STAMP));
	
	FORMAT DATE DATE9.;
	DROP TIME_STAMP TIMESTAMP AMOUNT RISK_SCORE;
	label Amd="Amount of the transaction"
		  Risk_per="Risk precentage associated with each transaction"
		  Date="Date of the transaction"
		  Time="Time of the transaction";
		  
run;



/*1- Checking the type of the data*/
proc contents data=LIB_MENT.METAVERSE out=lib_ment.Data_CONTENTS;
RUN;
/* --------------------- */
/* Creating a columns for the data types*/
DATA lib_ment.METAVERSE_TYPE;
	SET lib_ment.DATA_CONTENTS;
	IF TYPE=1 THEN NUMERICAL =NAME;
	ELSE IF TYPE =2 THEN CATEGORICAL=NAME;
RUN;

/*Printing the type of the data */
PROC PRINT DATA =lib_ment.METAVERSE_TYPE;
VAR CATEGORICAL NUMERICAL;
RUN;


/*Other way for checking the type of the variables*/
PROC SQL;
SELECT 
CASE WHEN TYPE EQ 1 THEN 'NUMERICAL'
	 WHEN TYPE EQ 2 THEN 'CATEGORICAL'
	 ELSE 'NON'
	 END AS VARIABLE_TYPE,
	NAME, LENGTH
	FROM DATA_contents
	Order  BY TYPE;
run;
/* -------------------------- */
/*creating macros for the variable type*/
%let Categorical = age_group anomaly Location_region Login_frequency purchase_pattern transaction_type DATE TIME;

%let Numerical=  Amd Risk_per session_duration ip_prefix hour_of_day;

/* ------------------------ */

/* 2- Checking the missing values for all the dataset */
proc format;
	value $Cate_miss ' '="missing" other="Not Missing";
	value Num_miss .="missing" other ="Not Missing";
run;

proc freq data=lib_ment.metaverse;
format _char_ $Cate_miss.;
tables _char_ /missing nocum nopercent missprint;
format _Numeric_ Num_miss.;
tables _Numeric_ / missing Nocum Nopercent missprint;
title "Missing Values for all Variables";
title "All the values generated by using proc format for specifying proc format";
run;

/* ---------------------------------------- */

/*3- Checking for missing values in categorical variabels*/
proc freq data=LIB_MENT.METAVERSE;
	format _Char_ $Cate_miss.;
	tables _char_ / list nocum nopercent;
	title "Number of Missing values for all Categorical Variables";
	footnote "all the values above are with A categorical type";
run;

/* ------------------------------------- */
/*4- Checking missing values for numerical variables */
proc means 
data =lib_ment.Metaverse nmiss;
var _Numeric_;
title "Missing values for all Numerical Variables";
run;


/* Other approach to check for missing values*/
proc mi data=lib_ment.metaverse nimpute=10;
var &Numerical;
run;


/* --------------------- */
proc contents data =LIB_MENT.METAVERSE;
run;


/* ----------------------------- */
/* 5- Statistical Summary*/

proc means data =LIB_MENT.METAVERSE qrange q1 q3 mean median mode std  max min n nmiss nonobs skewness;
var &Numerical;
run;

proc means data =LIB_MENT.METAVERSE;
Class anomaly purchase_pattern;
var risk_per session_duration;
run;
/*Observation: session duration reduced when the risk percentage increase*/

proc corr data=LIB_MENT.METAVERSE;
var Risk_per session_duration;
run;
/* now lets plot the result*/
proc sgplot data=lib_ment.metaverse;
scatter x=Risk_Per y=session_duration / markerattrs=(symbol=dot color=blue size=10);
reg x=Risk_Per y= session_duration / lineattrs=(color=red thickness=2);
title "scatterplot to show the relationship betweeen the duration and the risk assocaited with it";
xaxis label="Risk score";
yaxis label=" Duration";
run;

/*creating a regression for statistical inference*/ 
proc reg data=lib_ment.metaverse;
model Risk_per = Session_Duration amd;
run; 

/* creating a barplot to analyze the imapct of login frequency on Risk score*/
proc sgplot data=LIB_MENT.METAVERSE;
vbar Login_frequency / response= Risk_Per group= Purchase_Pattern stat= sum
fillattrs=group outlineattrs=(color=white thickness= 2);
xaxis label ="Login Frequency";
yaxis label = "Risk Precentage";
run;

/*explore the categorical variables*/
ODS GRAPHICS ON;
proc freq 
 data =LIB_MENT.METAVERSE nlevels;
 table &CATEGORICAL 
 / NOCUM LIST plots=freqplot(orient=vertical SCALE=PERCENT type=bar) chisq;
 title "Categorical variable frequency analysis";
 FORMAT DATE MONNAME.;
RUN;

/*--------------------------------------*/
/*explore the numerical variables*/
Ods graphics On;
proc univariate
data=LIB_MENT.METAVERSE plot;
var &Numerical;
histogram &Numerical / normal kernel ;
inset n mean std /position= ne;
probplot;
title "Numerical variable distribution analysis";
RUN;
 

proc summary data=lib_ment.metaverse print mean median mode std min max n nmiss Q1 Q3 ;
var &Numerical;
run;
 
/* ------------------------------ */
/* 6- Visualization*/
/* Box plot for the Risk asscocaited with purchase pattern*/
proc sgplot data=LIB_MENT.METAVERSE;
	vbox Risk_Per / category= purchase_Pattern;
	title "Risk Precentage based on the purchase pattern";
run;

/* a grouped bar plot between purchase pattern and anomlies detected with their respective risk scores*/
axis1 label=('MSRP') minor=none offset=(0,0);
axis2 label=none;
axis3 label=none offset=(7,7);
proc gchart data=LIB_MENT.METAVERSE;
vbar anomaly / discrete type= mean sumvar= Risk_Per group= purchase_pattern 
coutline= green patternid=group autoref raxis=axis1 maxis=axis2 raxis=axis3 noframe ;
Title "Anomalies detected based on the purchase pattern with their respective Risk Scores";
run;

/*A box plot for the risk score assocaited with the anomlies detected*/
proc sgplot data=Lib_ment.metaverse;
vbox Risk_Per / group= anomaly;
title "Risk Score associated with anomalies occurence";
run;

/*a box plot for the duration of the anomlies occurred*/
proc sort data=lib_ment.metaverse;
by anomaly;
run;
proc boxplot data=Lib_ment.metaverse;
plot session_duration* anomaly / boxstyle= schematic;
title "Examine the duration for the anomalies to be detected";
run;

/*A heat map for the risk level based on the amount and duration*/
ods graphics / reset width=6.4 in height= 4.8 in imagemap;
proc sgplot data=LIB_MENT.METAVERSE;
heatmap x=AMD y=session_duration / name= "Heat Map" colormodel=(blueviolet yellowgreen red)
													colorresponse=Risk_per
													nxbins=30
													nybins=30;
gradlegend / title ="Risk Level";
title "Heatmap that shows the distribution of the amount paid  vs Session Duration";
yaxis label ="Session Duration";
xaxis label="Amount paid";												
run;

/* a custom based Pie chart of the purchase pattern with their Risk precentages*/
proc template;
	DEFINE STATGRAPH PIECHART; 
		BEGINGRAPH;
		
	    	LAYOUT REGION;
	    		piechart category=PURCHASE_PATTERN response= RISK_PER / 
	    		datalabelcontent= (CATEGORY PERCENT) dataskin=gloss STAT=PCT;	
	    	ENDLAYOUT;
	    	
		ENDGRAPH;
	END;
RUN;

proc sgrender data=LIB_MENT.METAVERSE template= PIECHART;
TITLE "A PIE CHART FOR THE RISK ASSOCIATED WITH THE PURCHASE PATTERN TYPE";
RUN;

/*Display a density plot for the amount Risk and Session_Duration by location region*/

proc sgplot data=LIB_MENT.METAVERSE;
density Risk_Per / group= Location_region;
title "Risk Precentage grouped by Location Region";
xaxis label= "Risk Frequency";
yaxis label= "frequency";
run;

/* distribution of the amount paid based on the location region*/
proc sgplot data=lib_ment.metaverse;
density AMD / group =Location_Region;
title "Amount paid grouped by Location Region";
xaxis label= "Amount Paid";
yaxis label= "frequency";

run;

/* Distribution of the Duration spent based on the region*/
proc sgplot data=lib_ment.metaverse;
density Session_Duration / group=Location_region;
title "Session Duration grouped by Location Region";
xaxis label= "Session Duration";
yaxis label= "frequency";

run;


/*7- Identify Outliers*/

/* ------------------------ */
/* 7.1 Amount Paid */
proc univariate data=lib_ment.metaverse;
var Amd ;
output out=lib_ment.Outliered_Data pctlpts= 25 75 pctlpre= Q_;
run;

data lib_ment.Outliered_Data;
set lib_ment.Outliered_Data;
	iqr=Q_75 - Q_25;
	Lower_B= Q_25 - 1.5*iqr;
	Higher_B=Q-75 + 1.5* iqr;
	if AMD > Higher_B or AMD < Lower_B then Outlier_detected=1;
	else outlier_detected=0;
run;
proc sql;
select * from lib_ment.outliered_Data where outlier_detected EQ 1;
run;

/* ------------------------ */
/* 7.2 Seesion_Duration*/
proc univariate data=lib_ment.metaverse;
var Session_Duration ;
output out=lib_ment.Outliered_Data pctlpts= 25 75 pctlpre= Q_;
run;

data lib_ment.Outliered_Data;
set lib_ment.Outliered_Data;
	iqr=Q_75 - Q_25;
	Lower_B= Q_25 - 1.5*iqr;
	Higher_B=Q-75 + 1.5* iqr;
	if Session_Duration > Higher_B or Session_Duration < Lower_B then Outlier_detected=1;
	else outlier_detected=0;
run;

proc sql;
select * from lib_ment.outliered_Data where outlier_detected EQ 1;
run;

/* ------------------------- */
/* 7.3 Risk Percentage*/
proc univariate data=lib_ment.metaverse;
var Risk_Per ;
output out=lib_ment.Outliered_Data pctlpts= 25 75 pctlpre= Q_;
run;

data lib_ment.Outliered_Data;
set lib_ment.Outliered_Data;
	iqr=Q_75 - Q_25;
	Lower_B= Q_25 - 1.5*iqr;
	Higher_B=Q-75 + 1.5* iqr;
	if Risk_Per > Higher_B or Risk_Per < Lower_B then Outlier_detected=1;
	else outlier_detected=0;
run;
proc sql;
select * from lib_ment.outliered_Data where outlier_detected EQ 1;
run;
/* ---------------------------- */

/* Data Cleaning*/

/* Convert categorical columns to numeric */

/*1- -------------------------------------*/

/* Here we will calculate mean values for numerical columns */
proc means data=lib_ment.metaverse noprint;
   var hour_of_day session_duration amd; 
   output out=means_dataset mean=hour_mean session_mean amd_mean; 
run;

/* Check means calculated */
proc print data=means_dataset; 
run;

/* Replace missing values for numerical columns with mean value*/
data lib_ment.metaverse_cleaned;
set lib_ment.metaverse;
if _n_=1 then set means_dataset;
if amd EQ . then amd=amd_mean;
if session_duration EQ . then session_duration = session_mean;
if hour_of_day EQ . then hour_of_day = session_mean;
drop _Type_  _freq_ hour_mean amd_mean session_mean;
run;


/*2 ------------------*/

/* Filling the missing values for the Risk Percentage*/

/*-----------------------------*/
/*In the below code we will use combination of clustering and classification to identify the missing values for the Risk Score*/
proc freq data=lib_ment.metaverse_cleaned;
tables anomaly / out=lib_ment.freq_table;
run;

proc print data= lib_ment.freq_table;
run;
/*We sort the frequencies in the both tables for anomalies*/

proc sort data=lib_ment.freq_table;
by anomaly;
run;

proc sort data=lib_ment.metaverse_cleaned;
by anomaly;
run;

/* we merge it with cleaned dataset*/
data lib_ment.merged_data;
merge lib_ment.metaverse_cleaned(in=a)freq_table(in=b);
by anomaly;
if a ;
run;
/* Here we make a set for the data that contains missing values*/

data lib_ment.train_risk_data;
set lib_ment.merged_data;
where Risk_per NE .;
run;

/* Now we perform modelling on the training data*/
proc reg data=lib_ment.train_risk_data;
model Risk_Per=count;
output out= predicted_risk_value predicted=Risk_predicted;
run;
/* We apply the model on the test data (that contains missing values)*/
data lib_ment.cleanedData;
set lib_ment.metaverse_cleaned;
if Risk_per EQ . then set lib_ment.train_risk_data;
if Risk_per EQ . then Risk_per = Risk_predicted;
drop count Risk_predicted percent;
run;
/*--------------------------------------------------------------------------------------------*

/* Using CLASSIFICATION to handle missing data in categorical columns */

/* Check to confirm that there are no more missing values in categorical columns */
proc freq data=lib_ment.cleaneddata;
   tables location_region purchase_pattern age_group anomaly transaction_type / missing;
run;

/*Checking for missing values of categorical columns*/

proc means 
data =lib_ment.CleanedData nmiss;
var _Numeric_;
title "Missing values for all Numerical Variables";
run;

/*-----------------------------------------------*/
/* 1- Location Ragion*/
/* logistic regression for location_region */
data lib_ment.train_location_region lib_ment.test_location_region;
    set lib_ment.CleanedData;
    if location_region = '' then output lib_ment.test_location_region; /* Rows with 'unknown' */
    else output lib_ment.train_location_region; 
run;    

/* Train logistic regression model for location_region */
/*-----------------------------*/


proc logistic data=lib_ment.train_location_region;
    class transaction_type purchase_pattern age_group anomaly login_frequency/ param=ref;
    model location_region = amd login_frequency risk_per hour_of_day session_duration transaction_type purchase_pattern age_group anomaly;
    output out=lib_ment.predicted_location_region predprobs=individual;
run;

proc print data=lib_ment.predicted_location_region;
run;
/*-----------------------------------------------*/
/* Step 3: Apply the predicted values from logistic regression to replace missing location_region */

data lib_ment.final_metaverse;
    set lib_ment.CleanedData ;
    if location_region = '' then set lib_ment.predicted_location_region;
    if location_region = '' then location_region = _into_;
    keep hour_of_day	sending_address	receiving_address	transaction_type	location_region	ip_prefix	
    login_frequency	session_duration	
    purchase_pattern	age_group	anomaly	Amd	Risk_Per	DATE	TIME;
run;


proc contents data=lib_ment.final_metaverse;
run;
/*-------------------------------------------*/
/* Apply model to test dataset and replace 'unknown' with predicted values */

proc print data=lib_ment.final_metaverse;
where location_region is missing;
run;
/*----------------------------------------------------------------*/



/* 2- Purchase_pattern */

data lib_ment.train_purchase_pattern lib_ment.test_purchase_pattern;
    set lib_ment.final_metaverse;
    if purchase_pattern = '' then output lib_ment.test_purchase_pattern;
    else output lib_ment.train_purchase_pattern;
run;

/* Implementing logistic regression with variables that has relationship with the purchase pattern*/
proc logistic data=lib_ment.train_purchase_pattern;
    class transaction_type anomaly login_frequency / param=ref;
    model purchase_pattern = amd login_frequency risk_per session_duration transaction_type anomaly / firth;
    output out=lib_ment.purchase_pattern_prediction predprobs=individual;
run;

data lib_ment.final_metaverse_1;
    set lib_ment.final_metaverse;
    if purchase_pattern = '' then set lib_ment.purchase_pattern_prediction;
    if purchase_pattern = '' then purchase_pattern = _into_;
    keep hour_of_day	sending_address	receiving_address	transaction_type	location_region	ip_prefix	
    login_frequency	session_duration	
    purchase_pattern	age_group	anomaly	Amd	Risk_Per	DATE	TIME;
run;
/*-------------------------------------------*/
/*3- age_group */
data lib_ment.train_age_group lib_ment.test_age_group;
    set lib_ment.final_metaverse_1;
    if age_group = '' then output lib_ment.test_age_group;
    else output lib_ment.train_age_group;
run;

proc logistic data=lib_ment.train_age_group;
    class transaction_type location_region purchase_pattern anomaly login_frequency/ param=ref;
    model age_group = amd login_frequency risk_per hour_of_day session_duration transaction_type location_region purchase_pattern anomaly;
    output out=lib_ment.age_group_prediction predprobs=individual;
run;

data lib_ment.final_metaverse_2;
    set lib_ment.final_metaverse_1;
    if age_group = '' then set lib_ment.age_group_prediction;
    if age_group = '' then age_group = _into_;
    keep hour_of_day	sending_address	receiving_address	transaction_type	location_region	ip_prefix	
    login_frequency	session_duration	
    purchase_pattern	age_group	anomaly	Amd	Risk_Per	DATE	TIME;
run;


/*-----------------------------------------*/

/*4- transaction_type */
data lib_ment.train_transaction_type lib_ment.test_transaction_type;
    set lib_ment.final_metaverse_2;
    if transaction_type = '' then output lib_ment.test_transaction_type;
    else output lib_ment.train_transaction_type;
run;

proc logistic data=lib_ment.train_transaction_type;
    class purchase_pattern age_group anomaly login_frequency/ param=ref;
    model transaction_type = amd login_frequency risk_per session_duration  purchase_pattern age_group anomaly;
    output out=lib_ment.transaction_type_prediction predprobs=individual;
run;

data lib_ment_Prepared_Meta;
    set lib_ment.final_metaverse_2;
    if transaction_type = '' then set lib_ment.transaction_type_prediction;
    if transaction_type = '' then transaction_type = _into_;
    keep hour_of_day	sending_address	receiving_address	transaction_type	location_region	ip_prefix	
    login_frequency	session_duration	
    purchase_pattern	age_group	anomaly	Amd	Risk_Per	DATE	TIME;
run;
/*--------------------------------------------------------------*/
/* Checking missing values again*/
proc format;
	value $Cate_miss ' '="missing" other="Not Missing";
	value Num_miss .="missing" other ="Not Missing";
run;

proc freq data=lib_ment_Prepared_Meta;
format _char_ $Cate_miss.;
tables _char_ /missing nocum nopercent missprint;
format _Numeric_ Num_miss.;
tables _Numeric_ / missing Nocum Nopercent missprint;
title "Missing Values for all Variables";
title "All the values generated by using proc format for specifying proc format";
run;

proc contents data=lib_ment_Prepared_Meta;
run;

/*---------------------------------------------------------------*/

/* Apply Clustering Method to Handle Noisy Data */

/* Here I will standardize the data before clustering */
proc standard data=lib_ment_Prepared_Meta mean=0 std=1 out=lib_ment.standardized_metaverse;
   var amd risk_per hour_of_day session_duration;
run;

proc print data=lib_ment.standardized_metaverse(obs=10);
run;

/* Perform k-means clustering with a specified number of clusters and calculate distances */
proc fastclus data=lib_ment.standardized_metaverse maxclusters=5 out=lib_ment.clustered_metaverse distance;
   var amd risk_per hour_of_day session_duration;
run;

/* Now we check  check the cluster assignment and distance from centroid */
proc print data=lib_ment.clustered_metaverse(obs=30);
   var amd risk_per cluster DISTANCE;
run;


proc print data=lib_ment.clustered_metaverse;
   var amd risk_per DISTANCE;
run;



/*-----------------------------------------------------------------------------------*/
/* Here we will check for potential outliers 
(noisy data) based on a high distance 
from centroid and implementing binning (equi_width)method for the detected once */
data lib_ment.noisy_data_flagged;
   set lib_ment.clustered_metaverse;
   if DISTANCE > 2 then do;
      /* Bin noisy data into 5 groups */
      amd = round(amd * 4) + 3;
      risk_per = round(risk_per * 4) + 3;
      hour_of_day = round(hour_of_day * 4) + 3;
      session_duration = round(session_duration * 4) + 3;
      /* Update DISTANCE for binned data */
      DISTANCE = 2; /* Set to threshold value */
   end;
run;

/* Checking for the existence if the total observation is 5000 then the data is clean*/
data lib_ment.cleaned_metaverse_dataset;
   set lib_ment.noisy_data_flagged;
   if DISTANCE lE 2; /* Keep only clean data */
run;


/* Final Step: Export the cleaned and imputed dataset */
proc export data=lib_ment.cleaned_metaverse_dataset
   outfile="/home/u63929852/Cleaned_data/final_metaverse_dataset.xlsx"
   dbms=xlsx replace;
run;

/*-------------------------------------------------------*/

libname Exercise BASE '/home/u63929852/SAS_Assignment';
data Exercise.metaversetransactioncleaned;
set lib_ment.cleaned_metaverse_dataset;
drop Cluster distance;

/* 4. Data Integration and Transformation */
  /* 4.1 Normalization: scale numerical variables to the range [0,1] */
PROC STDIZE DATA=Exercise.metaversetransactioncleaned OUT=Exercise.metaversetransactionNormalised METHOD=RANGE REPLACE;
    VAR amd risk_per session_duration;
RUN;

  /* 4.2 Standardization: Z-score normalization */
PROC STANDARD DATA=Exercise.metaversetransactioncleaned OUT=Exercise.metaversetransactionstandardised MEAN=0 STD=1;
    VAR amd risk_per session_duration;
RUN;

 /* 4.3 Encoding Categorical Data */
   /* One-hot encoding for categorical variables */
PROC TRANSREG DATA=Exercise.metaversetransactioncleaned DESIGN;
    MODEL CLASS(age_group location_region transaction_type login_frequency/ ZERO=NONE);
    OUTPUT OUT=Exercise.metaversetransactionEncoded;
RUN;
    
    /* Assigning unique integer labels to each category */
DATA Exercise.metaverseLabelEncoded;
    SET Exercise.metaversetransactioncleaned;
    
      /* Encode age_group */
    IF age_group = 'Young' THEN age_group_code = 1;
    ELSE IF age_group = 'Middle_Aged' THEN age_group_code = 2;
    ELSE IF age_group = 'Senior' THEN age_group_code = 3;
    ELSE age_group_code = 0; /* 'Unknown' */
    
      /* Repeat for other categorical variables (e.g., transaction_type) */
    IF transaction_type = 'Transfer' THEN transaction_type_code = 1;
    ELSE IF transaction_type = 'Phishing' THEN transaction_type_code = 2;
    ELSE IF transaction_type = 'Suspicious' THEN transaction_type_code = 3;
    ELSE transaction_type_code = 0; /* 'Unknown' */
RUN;


DATA Exercise.metaversetransformTime;
    SET Exercise.metaverseFeature;

    /* Extract day of week, hour, month from timestamp */
    day_of_week = WEEKDAY(DATE); /* Day of the week (1 = Sunday, 7 = Saturday) */
    hour_of_day = HOUR(TIME);    /* Hour of day (0-23) */
    month = MONTH(DATE);         /* Extracts month */
RUN;

  /* Creating commonkeyvariable in metaversetransformTime */
DATA Exercise.metaversetransformTime;
    SET Exercise.metaversetransformTime;
    commonkeyvariable = CATX('_', sending_address, receiving_address);
RUN;

  /* Creating commonkeyvariable in metaversetransactionEncoded */
DATA Exercise.metaversetransactionEncoded;
    SET Exercise.metaversetransactionEncoded;
    commonkeyvariable = CATX('_', sending_address, receiving_address);
RUN;

    /* Creating commonkeyvariable in metaversetransactionstandardised */
DATA Exercise.metaversetransactionstandardised;
    SET Exercise.metaversetransactionstandardised;
    commonkeyvariable = CATX('_',  sending_address, receiving_address);
RUN;


/* 4.4 Feature Engineering (New Variables) */
   /* Create interaction terms between numerical variables */
DATA Exercise.metaverseFeature;
    SET Exercise.metaverseLabelEncoded;
    
    /* Interaction between amount and risk_score */
    amount_risk_interaction = amd * risk_per;
    
    /* Log-transform amount (handle non-positive values separately) */
    IF amd > 0 THEN log_amount = LOG(amd);
    ELSE log_amount = .;
RUN;


  /* Creating commonkeyvariable in metaversetransactionEncoded */
DATA Exercise.metaversetransactionEncoded;
    SET Exercise.metaversetransactionEncoded;
    commonkeyvariable = CATX('_', sending_address, receiving_address);
RUN;

    /* Creating commonkeyvariable in metaversetransactionstandardised */
DATA Exercise.metaversetransactionstandardised;
    SET Exercise.metaversetransactionstandardised;
    commonkeyvariable = CATX('_', sending_address, receiving_address);
RUN;

PROC CONTENTS DATA=Exercise.metaversetransactionEncoded;
RUN;


PROC CONTENTS DATA=Exercise.metaversetransactionstandardised;
RUN;
 

/* Sort the metaversetransactionstandardised dataset */
PROC SORT DATA=Exercise.metaversetransactionstandardised;
    BY commonkeyvariable;
RUN;

      
     /* 5. DATA REDUCTION */
 /* 5.1 Principal Component Analysis */
PROC STDIZE DATA=Exercise.metaveretransformedcomplete OUT=Exercise.metaverseImputed METHOD=MEAN REPLACE;
    VAR amd risk_per session_duration hour_of_day ip_prefix;
RUN;
  
DATA Exercise.metaverseForPCA;
    SET Exercise.metaverseImputed;
    DROP _TYPE_ _NAME_;
RUN;

PROC PRINCOMP DATA=Exercise.metaverseForPCA OUT=Exercise.PCAResults;
    VAR amd risk_per session_duration hour_of_day ip_prefix;
RUN;
 
 /* 5.2 Feature Selection using forward selection */
PROC GLMSELECT DATA=Exercise.metaveretransformedcomplete;
    CLASS transaction_type location_region age_group login_frequency;
    MODEL risk_per = transaction_type location_region age_group login_frequency session_duration hour_of_day / SELECTION=FORWARD;
RUN;
